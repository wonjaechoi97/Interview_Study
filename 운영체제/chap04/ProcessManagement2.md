# 🌐Process Management 2

## 프로세스의 생성

- 부모 프로세스가 자식 프로세스를 생성한다.
    - 부모 프로세스를 자신을 복제해서 자식 프로세스를 복제해서 생성한다.
    - 주소 공간(코드, 데이터, 스택)과 프로그램 카운터(인스트럭션을 어디 까지 수행했는가 나타내는 레지스터)와 같은 문맥 등 자원도 모두 복제된다.
    - 보통 자식은 복사한 부모의 공간을 복사한 공간에 새로운 프로그램을 올린다.
    - 리눅스와 같은 운영체제는 같은 내용을 수행하다가 각자의 길을 가게 되면 부모와 공유하던 메모리 공간 일부를 카피해서 자식이 갖게 된다.
    - 이러한 기법을 **copy-on-write**라고 한다.
    - 한 부모가 여러 자식을 생성할 수 있기 때문에 프로세스의 트리를 형성한다.
    - 프로세스는 자원을 필요로 한다.
        - 운영체제로부터 자원을 받는다.
        - 부모와 자원을 공유한다.
        - 
- 자원 공유 모델.
    - 부모와 자식이 모든 자원을 공유하는 모델.
    - 일부를 공유하는 모델.
    - 전혀 자원을 공유하지 않고 부모와 자식이 cpu등의 자원을 두고 경쟁하는 모델(일반적 모델)
- 수행(execution) 모델.
    - 부모와 자식이 공존하며 수행되는 모델.
    - 자식이 종료될 때까지 기다리는 모델.

## 프로세스 생성 fork & exec

### fork
- fork() 시스템 콜이 새로운 프로세스를 생성한다.
    
    
- 운영체제에게 자식을 만들어 달라고 부탁해야 하기 때문에 “시스템 콜”이다.
    - 부모를 그대로 복사하여 주소 공간을 할당한다.
    - 부모 프로세스는 fork의 리턴 값으로 양수를 받고 자식은 0을 받기 때문에 자식이 원본 행세를 하거나, 자식과 부모가 완전히 같은 프로그램 흐름을 가지는 것을 방지할 수 있다.
    - if(pid==0)을 사용해서 자식과 부모의 흐름을 분리할 수 있다.

```C
    int main(){
        int pid;
        pid=fork(); //자식 프로세스는 이 이후부터 실행하게 된다. 부모의 프로그램 카운터를 물려 받기 때문에 
        if(pid==0)
            printf("\n Hello, I am child!\n");
        else if (pid>0)
            printf("\n Hello, I am parent!\n");
    }
```
- fork()의 return 값이 양수
    - 부모는 양수 자식은 0 
    - **의문점 : 자식은 pid = fork()를 실행하지 않았는데 어떻게 pid값을 가지는가? 기본 값이 0이어서 그런가?**

### exec
- fork 다음에 이어지는 exec() 시스템 콜을 통해서 새로운 프로그램을 주소에 올린다.
    - execlp가 exec 시스템 콜을 하게 된다.
    - execlp를 만나면 이전 기억은 완전 잊고 새로운 프로그램으로 덮어 씌운다.
    - fork부분부터 위로 없애고 exec하면 원래의 프로그램은 잊어버리고 새로운 프로그램을 시작한다.
    - 이렇게 되면 exec이후의 코드는 영원히 실행될 수 없다.
- 굳이 fork() 후에 execlp()할 필요는 없다. 
- execlp 파라미터로는 프로그램명 2회 적고, 프로그램에게 전달할 아규먼트들을 적고, (char*)0 이런식으로 적는다.

```C
    int main(){
        int pid;
        pid=fork();에 
        if(pid==0)
            printf("\n Hello, I am child! Now I'll run date \n");
            execlp("/bin/date", "/bin/date",(char*)0); //이전의 기억은 잊고 date라는 새로운 프로그램(코딩한)으로 덮어 씌워진다.
        else if (pid>0)
            printf("\n Hello, I am parent!\n");
    }
```

- date 프로그램 예시
```C
    int main(){ 
    .
    .
    .
    }
    
```
    
### wait() 시스템 콜

- 프로세스가 wait() 시스템  콜을 호출하면
    - 커널은 자식 프로세스가 종료될 때까지 부모 프로세스를 block 상태로 만든다.
    - 자식 프로세스가 종료되면 커널은 부모 프로세스를 깨운 후 ready상태로 만든다.
    - 프롬프트와 프롬프트로 실행하는 프로그램과 같다
        - 프로그램을 실행하면 block상태가 되어 입력 못 하다가 실행한 프로그램(자식 프로세스)이 종료 되면 명령 프롬프트가 다시 입력이 가능하게 된다(ready). 
    - 부모 자식이 cpu 제어권을 두고 경쟁하는 모델과는 다른 모델이다.

## 프로세스의 종료

### exit()
- 자발적 종료
    - 마지막 실행 문 수행 후 exit() 시스템 콜을 통해 이루어진다.
    - 프로그램에 명시적으로 주어주지 않아도 메인 함수가 리턴되는 위치에 컴파일러가 넣어준다.

- 비자발적 종료
    - 부모 프로세스가 자식 프로세스를 강제로 종료 시킨다.
        - 자식 프로세스가 자원의 한계치를 넘어서는 자원을 요청하거나,
        - 자식에게 할당된 태스크가 더 이상 필요하지 않은 경우.
    - 키보드로 kill, break를(ctrl+c, x 클릭) 친 경우.
    - 부모 프로세스가 종료하는 경우.
        - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다.
        - 트리의 최상단이 죽어야 하면 가장 말단의 프로세스부터 죽기 시작.

## 프로세스 간 협력

- 독립적 프로세스
    - 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로는 하나의 프로세스는 다른 프로세스에게 영향을 미치지 못하고 독립적이다.
- 협력 프로세스
    - 협력해야지만 더 효율적인 경우  
    - 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.
- 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
    - 메시지를 전달하는 방법
        - message passing : **커널을 통해** 메세지를 전달한다.
        - 프로세스 사이에는 공유 변수를 일체 사용하지 않고 통신하는 시스템
        - Process A가 Process B에게 메세지를 보내고 이에 영향을 받아 B가 수행이 된다.
            - Direct Communication :  통신하려는 프로세스의 이름을 명시
            - Indirect Communication :  mailbox를 통해 메시지를 간접 전달(아무나 꺼내 가라).
    - 주소 공간을 공유하는 방법
        - 서로 다른 프로세스 간에도 일부 주소 공간을 공유한다.
            - 서로 독립적으로 메모리 공간(코드 데이터 스택) 가지더라도 물리적 메모리에 매핑할 때 일부 메모리 공간을 공유하도록 하는 방식
            - 커널에 메모리 공유 하는 것을 시스템 콜로 알려주어야 함
        - 프로세스 간 신뢰도가 높아야 한다.
    - thread: 사실상 하나의 프로세스이기 때문에 프로세스 간 협력으로 보긴 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하기 때문에 협력이 가능하다.

### Message passing

- Message system
    - 프로세스 간 메모리 공유 없이 통신하는 시스템
    - 원칙적으로 프로세스가 다른 프로세스에게 직접 영향을 미칠 방법은 없다.
- Direct Communication
    - 통신하려는 대상 프로세스를 명시하는 방법이다.
- Indirect Communication
    - 통신 대상을 명시하지 않고 메일 박스에 넣어두면 다른 프로세스가 메일 박스를 열고 읽는 방법이다.

# CPU Scheduling

## CPU burst & I/O burst

- cpu를 사용하는 일련의 단계를 cpu burst라고 한다.
- I/O를 수행하는 일련의 단계를 I/O burst 라고 한다.
- 빈도에 따라 cpu bound 프로세스와 IO bound 프로세스로 나뉜다.
    - IO bound 프로세스 : CPU를 잡고 계산하는 시간보다 입출력에 많은 시간이 필요한 job이고, cpu burst가 짧고 빈번하다.
        - interactive한 job
        - 가능한 사람과 interact한 job에 cpu할당을 더 해주는 것이 이상적.
    - cpu bound 프로세스 : 계산 위주의 job이고 cpu burst가 길고 적다.
- 때문에 CPU 스케줄링이 필요하다.

## CPU Scheduler & Dispatcher

- 둘 모두 운영체제 안의 코드 부분에 속해 있다.
- CPU Scheduler(운영체제 내의 코드)
    - Ready 상태의 프로세스 중에서 어떤 프로세스에게 CPU를 줄지 결정한다.
- CPU  Dispatcher(운영체제 내의 코드)
    - CPU제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘기는 작업을 수행한다.
    - 이 과정을 문맥 교환이라고 한다.
- CPU 스케줄링 필요한 경우는 다음과 같다.(알고만 있자)
    1. Running → Blocked(예: I/O를 요청하는 시스템 콜)
    2. Running → Ready(예: 타이머 인터럽트)
    3. Blocked → Ready(예: I/O 완료 인터럽트)
        - IO 끝난 프로세스가 우선순위가 가장 높다면 원래 수행 중이던 프로세스는 cpu 뺏기는 경우가 있다.
    5. Terminate
    
    
    - 1, 4는 자진으로 반납하는 경우이다.
    - 2, 3은 강제로 빼앗기는 경우이다.
    - **nonpreemptive(자진 반납), preemptive(강제)** 용어에 익숙해지자!

# 컴퓨터 시스템 구조

하드웨어의 동작과 하드웨어 위에서 프로그램이 돌아가는 방식.

<img width="600" src="https://github.com/wonjaechoi97/Interview_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/img/시스템%20구조.png">

## 프로그램의 실행 방식

- **CPU**는 메모리의 사용자 프로그램이나 운영체제가 지시한 작업(인스트럭션)을 수행한다.
- 운영체제의 CPU 관리 방식에 따라 프로그램에 CPU의 제어 권한을 분배한다.
- 제어 권한을 줄 때 타이머에 값을 세팅하고 시간이 끝나면 타이머가 CPU에게 인터럽트를 하고 운영체제에게 제어권이 반환되어 특정 프로그램의 CPU독점을 막는다.
- 사용자 프로그램이 입출력 장치의 작업이 필요하면 직접 접근할 수 없기 때문에 인터럽트를 통해서 운영체제에게 제어권을 반환하고 운영체제가 CPU를 통해 프로그램이 요청한 입출력 장치에 접근하여 작업 지시한다.

## Mode bit

- Mode bit가 0이면 운영체제가 제어권을 가지고 있고, 1이면 사용자 프로그램이 제어권을 가진 상태이다.
- 보안을 위해서 Mode bit가 1인 경우에는 다른 장치에 대한 접근에 제한이 있는 일반 명령만 수행가능하다.
- 보안을 해칠 수 있는 중요한 명령어는 Mode bit가 0인 모니터 모드(커널 모드)에서 수행 가능하다.

## Device controller

- 각 입출력 장치를 제어하기 위한 작은 CPU이다.
- 작업 공간으로 메모리와 같은 로컬 버퍼를 가진다.
- 입출력 장치의 작업이 완료되면 CPU에 인터럽트로 작업 완료를 알린다.
- device driver는 CPU가 입출력 장치의 작업을 수행 시키기 위해 필요한 코드를 담고 있는 소프트웨어이다.

## Interrupt
- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- 좁은 의미에서 인터럽트는 타이머, 입출력 장치 같은 하드웨어가 발생 시킨 하드웨어 인터럽트이다.
  - 타이머
    - 정해진 시간 흐른 후 운영체제에게 제어권 넘어가도록 인터럽트 발생
    - 매 클럭 틱 때마다 1씩 감소
    - 타이머 값이 0이 되면 인터럽트 발생
    - 특정 프로그램의 cpu독점 방지
    - time sharing구현에 활용
    - +현재 시간 계산
- 넓은 의미에서 인터럽트는 입출력 장치의 작업 등 운영체제가 필요한 경우 직접 CPU에 인터럽트를 걸어 운영체제에게 제어권을 넘겨주는 **System call**과 같은 **Trap**(소프트웨어 인터럽트)도 포함한다.
  - **Exception** : 다른 사용자 프로그램 메모리 접근, divide by zero와 같은 상황 처럼 **프로그램이 오류를 범한 경우**
  - **System call** : 사용자 프로그램이 커널 함수를 호출하는 경우
- **시스템 콜**이란 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출한 것이다.
- **현대의 운영체제는 인터럽트에 의해 구동 된다.**
- 인터럽트 종류에 따라 실제 처리할 코드를 인터럽트 루틴이라 하고, 이 루틴을 가리키는 것이 인터럽트 벡터이다.
- **인터럽트 벡터**
  - 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
- **인터럽트 처리 루틴(인터럽트 핸들러)**
  - 해당 인터럽트를 처리하는 커널 함수

## IO수행

- 모든 입출력 명령은 특권 명령이다.
- IO수행이 필요하면 시스템 콜을 통해서 제어권을 운영체제에게 넘겨주며 IO요청한다.
- 인터럽트 벡터의 특정 위치로 이동 후 제어권이 인터럽트 벡터가 가리키는 인터럽트 루틴으로 이동한다.
- 보안을 해칠 수 있기 때문에 올바를 요청인지 확인 후 IO를 수행한다.
- IO완료 시 제어권을 시스템콜 다음 명령으로 옮긴다.
- CPU가 너무 자주 인터럽트를 당하면 효율이 떨어지기 때문에 DMA가 직접 메모리에 접근할 수 있으나 CPU에 동시에 접근하여 일관성이 깨지는 문제를 방지하기 위해 메모리 컨트롤러의 관리를 받는다.
- IO의 모든 작업이 완료되면 CPU에 한 번만 인터럽트 하여 알려준다.

# 컴퓨터 시스템 구조와 프로그램 실행 2️⃣

## IO Device

- 컴퓨터에 데이터를 집어 넣는 input 작업이나 데이터를 받아와 출력하는 output작업을 수행하는 장치이다.
- **I/O Device Controller**
  - 해당 I/O장치를 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register 가짐.
    - cpu가 지시하기 위한 레지스터
  -  작업 공간으로 로컬 버퍼를 사용하여 데이터를 로컬 버퍼에 저장한다.
    -담은 데이터를 화면에 출력 or 
  - 실제 I/O는 device와 local buffer 사이에서 일어난다.
## CPU

- CPU는 매 순간 메모리의 특정 위치의 기계어(인스트럭션)을 읽어와서 실행한다.
- CPU의 레지스터 중 하나(프로그램 카운터)가 메모리의 주소를 가지는데 그 주소를 가리키는 메모리 위치에서 인스트럭션(주로 4바이트)을 읽어와서 실행한다.
- 인스트럭션을 실행하고 다음 인스트럭션으로 넘어가기 전 인터럽트를 확인한다.
- 인터럽트가 오면 CPU의 제어권은 운영체제에게 돌아간다
- Mode bit이 0이면 커널 모드로 입출력 장치 접근 메모리 접근 등 모든 명령어를 실행 가능하다.
- Mode bit이 1인 경우 사용자 모드로 몇몇 보안을 위협하는 명령어를 사용하지 못한다.


## 동기식 입출력과 비동기식 입출력

- 동기식 입출력
  - 동기식 입출력은 입출력을 시키고 시킨 작업이 완료된 후에 제어권이 사용자 프로그램에게 넘어가는 입출력 방식이다.
    - IO가 완료될 때까지 CPU를 *낭비시키는* 방법.
      - IO도 하나의 작업만 할 수 밖에 없음
    - IO가 완료될 때까지 제어권을 뺏어와서 다른 프로그램에게 주는 방법.
      - IO작업 기다리는 줄에 그 프로그램을 세운다.
    - 읽어와야 하는 상황에서 읽은 후에 프로그램이 진행되는 경우에는 동기식 입출력을 사용한다.

- 비동기식 입출력
  - 비동기식 입출력은 IO 시작 후 입출력 작업 완료를 기다리지 않고 다시 제어권을 얻어 다른 작업을 수행하는 경우이다.
  - 데이터를 쓰는 경우 데이터가 잘 쓰이는지 확인하지 않고 바로 다음 작업을 진행해도 되는 경우 비동기식 입출력이 사용된다.
  - 주로 writing
- 두 경우 모두 IO 작업 완료는 인터럽트를 통해서 알려준다.

## 메모리 컨트롤러
- 메모리 제어하는 장치
- 동시에 메모리 접근 등을 통제할 수 있다.


## DMA(Direct Memory Access)

- 원래 메모리에 접근 가능한 장치는 CPU밖에 없으나 작은 IO 작업에도 인터럽트가 들어오면 CPU활용이 비효율 적이기 때문에  DMA를 사용하여 CPU의 중재 없이 device controller가 device의 버퍼의 내용을 메모리에 블록 단위로 직접 전송한다.
- DMA가 작은 단위가 아닌 **블록 단위로 인터럽트**를 발생 시켜서 인터럽트의 빈도를 줄인다.
- DMA가 작은 io도 메모리에 복사하는 역할을 하고 그 작업이 모두 끝나면 **CPU에 인터럽트를 딱 한 번 걸어준다.**
- 너무 자주 인터럽트는 오버헤드가 큼
  - device 버퍼에 내용이 어느 정도 쌓일 때까지 기다림.**(?)**

## 서로 다른 입출력 명령어

- 보통 IO인스트럭션과 메모리 접근 인스트럭션이 따로 존재해서 Special 인스트럭션에 의해 입출력이 수행된다.
- 하지만 메모리 접근하는 인스트럭션으로 IO에 접근하는 경우도 있다.

## 저장장치 계층 구조

<img width="600" src="https://github.com/wonjaechoi97/Interview_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/img/저장장치계층.png">

- 레지스터 위에 CPU가 존재하고 위로 올라갈 수록 속도가 빠르고, 비싸고, 용량이 작다.
- CPU는 빠르게 인스트럭션을 처리하는데 DRAM과 같은 메인 메모리에 접근하는 것은 시간이 오래 걸리기 때문에 속도 차이를 완충 하기 위해 캐시 메모리를 가진다.
- 캐시 메모리의 크기가 작기 때문에 필요한 것만 올려서 사용하고 새로운 것이 들어오면 기존의 것을 내보내야 하는 경우도 생긴다.
- CPU가 직접 접근하는 저장 장치를 Primary storage라고 하고, 직접 접근하지 않는 장치를 Secondary storage라고 한다.

## 프로그램 실행

- 프로그램은 실행 파일 형태로 하드 디스크에 저장되어 있다가 실행 파일이 실행되면 메모리에 올라가서 프로세스가 되어 실행된다.
- 메모리에 올라가기 프로그램은 실행되면 코드, 데이터, 스택으로 이루어진 독자적인 주소 공간이 생기고 이 중 당장 필요한 부분만 메모리에 올려서 사용하게 된다.
- 코드는 기계어 실행에 필요한 코드를 담고, 데이터는 프로그램이 사용하는 자료구조를 담고 있고, 스택은 함수 호출, 리턴에 필요한 공간이다.
- 논리적인 주소를 물리적인 주소로 변환하는 작업이 필요하다.

## 커널 주소 공간

- 커널 주소 공간의 코드 부분에는 시스템 콜, 인터럽트 처리를 위한 코드와 자원 관리를 위한 코드, 서비스 제공을 위한 코드가 있다.
- data 영역에는 CPU, 메모리 등을 관리하는 데 필요한 자료구조가 있고, 프로세스를 관리하기 위한 자료구조(PCB)도 있다.
- 함수 호출과 리턴에 필요한 스택 영역도 가지고 있다.

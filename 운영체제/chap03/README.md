# 🌐Process1

## 프로세스

- 프로세스는 실행 중인 프로그램이다.(Program in execution)

### 프로세스의 문맥

- 프로세스의 문맥이란 CPU의 수행 상태를 나타내는 정보이다.
- 특정 시점에서 이 프로그램이 어디까지 수행되었는지 확인할 수 있는 정보이다.
- 하드웨어 문맥으로 Program Counter와 각종 레지스터가 있다.
- 프로세스의 주소 공간인 code, data, stack도 문맥 중 하나이다.
- 프로세스 관련 커널 자료 구조인 PCB와 커널 스택도 문맥 중 하나이다.
- 프로세스가 실행 될 때마다 커널 주소 공간에는 프로세스 마다 pcb라는 프로세스를 관리할 자료구조를 가진다.
- 프로세스 실행 중 다른 프로세스에게 제어권이 넘어가 경우 다음 번에 제어권을 얻었을 때 문맥을 알고 있어여 지난번에 멈춘 부분에서 시작할 수 있다.
>  #### 크게 3 가지
> - CPU 수행 상태를 나타내는 하드웨어 문맥
>   - Program Counter: 어디를 가리키고 있었나?
>   - 각종 register : 어떤 값을 가지고 있었나?
>   - 인스트럭션의 어디까지 수행했는지 파악 가능
> - 프로세스의 주소 공간
>   - code, data, stack
> - 프로세스 관련 커널 자료 구조
>   - PCB : 운영체제가 process를 관리하기 위해 data에 만든 자료구조, cpu, 메모리 할당 관리 및 보안 침해 여부 관리 
>   - kernel stack: 어떤 프로세스든 운영체제에 요청할 때에는 커널의 코드를 실행 , 커널에서 함수 호출이 일어나서 stack에 정보를 쌓을 때 프로세스 별로 stack을 별도로 둔다.
> 
>

## 프로세스의 상태

- 프로세스는 상태가 변경되며 수행된다.
- Running
  - CPU를 잡고 인스트럭션을 수행중인 상태이다.

- Ready
  - CPU 제어권을 얻기 위해 기다리는 상태이다.
  - 메모리 등 다른 조건은 모두 만족한 생태.
  - 프로그램이 시작되면 무조건 Ready상태가 된다.
  - Running 상태에서 타이머와 같은 인터럽트가 발생하면 Ready상태가 된다.

- Blocked(wait, sleep)
  - CPU를 주어도 당장 인스트럭션을 수행할 수 없는 상태이다.
  - I/O같이 프로세스가 요청한 이벤트가 만족 되지 않아 이를 기다리는 상태이다.
  - 실행할 부분이 메모리에 없고 디스크에 내려가 있는 상태

- 경우에 따라 프로세스가 생성 중인 New상태와 수행이 끝나서 정리 중인 Terminated상태가 추가된다.
- 프로세스들은 CPU의 Ready 큐, 공유 데이터의 큐, I/O 큐에서 대기하면서 나름의 작업을 계속 수행한다.
![프로세스 상태도](https://user-images.githubusercontent.com/62707891/178740191-86d59152-8307-41ad-8e84-ca791e3b266f.jpg)



### 상황 예시

![process1](https://user-images.githubusercontent.com/62707891/178742528-5cc295ae-435f-4445-b0b1-1d0b1b8a574d.png)

  - Running 상태 -> I/O작업 필요 -> cpu제어 반납 ->문맥교환-> blocked 상태 후 I/O장치 queue-> 완료 되면 **인터럽트** -> cpu 제어권 OS에게 ->
  os가 I/O결과 프로세스 메모리 공간에 넣음 -> OS가 프로세스 상태 Ready로 바꾼 후 Ready queue에 넣어줌
  
  - 공유 데이터에 접근 중에 cpu 제어권을 뺏겼을 경우 다른 프로세스가 접근해서 공유 데이터를 처리하면 **일관성** 깨지는 문제 발생 
  먼저 쓰던 프로세스가 다 쓸 때 까지 Resource queue에서 대기.


## Process Control Block(PCB)
![pcb](https://user-images.githubusercontent.com/62707891/178743631-68eff067-333f-4b09-bc68-d64ec31ec8d6.jpg)


- 운영체제가 각 프로세스를 관리하기 위해서 프로세스 당 유지하는 정보
- 다음의 구성 요소를 가진다.
- OS가 관리에 사용하는 정보
  - 프로세스 상태(ready, running, ...), 프로세스 ID
  - 스케쥴링 정보, 우선순위

- CPU 수행 관련 하드웨어 값(프로세스 문맥)
  - Program counter, register

- 메모리 관련 정보
  - Code, data, stack의 위치 정보

- 파일 관련 정보
- ...


## 문맥 교환

- CPU제어권을 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- CPU가 다른 프로세스에게 넘어갈 때 OS는 다음을 수행한다.
  - CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장한다
  - cpu의 레지스터 값 program counter 값 저장(커널의 문맥 저장 위한 pcb에) 
  - CPU를 새롭게 얻게 되는 프로세스의 상태를 PCB에서 읽어옴
  - PCB는 커널 공간의 data에 존재한다.

- 시스템 콜이나 인터럽트 발생 시 반드시 문맥 교환이 일어나지 않는다.
- 인터럽트나 시스템 콜 처리 이후에 다시 같은 프로세스에게 제어권이 넘어가면 문맥이 교환되지 않는다.
- 다만 이 경우에도 CPU 수행 정보 등 일부 문맥을 PCB에 저장해야 한다.

## 프로세스를 스케줄링하기 위한 큐

- Job queue
- 현재 시스템 내에 있는 모든 프로세스의 집합

- Ready queue
- 현재 메모리 내에 있으면서 CPU를 얻어 실행되기를 기다리는 프로세스 집합

- Device queues
- I/O 장치의 처리를 기다리는 프로세스 집합

- 프로세스들은 각 큐를 오가며 수행된다.줄러

## 스케줄러(scheduler)

- Long-term scheduler(job scheduler)
  - ### 안쓴다
  - 시작 프로세스 중 어떤 것들을 Ready queue로 보낼지 결정한다.
  - 프로세스에게 메모리를 할당할지 결정한다.
  - 메모리에 올라간 프로세스의 수가 너무 적어도(자원 낭비) 많아도(실행에 필요한 최소한 메모리가 없어짐) 성능에 안 좋다.
  - 메모리에 프로세스를 몇 개 올릴지 정하는 **degree of Multiprogramming**을 제어한다.
  - 보통 시분할 시스템에서는 사용하지 않는다. **보통 프로그램이 시작되면 무조건 Ready 상태**가 된다.

- Short-term scheduler(cpu scheduler)
  - 어떤 프로세스를 다음번에 running시킬 지 결정한다.
  - 프로세스에게 CPU를 할당하는 문제를 결정한다.

- Medium-term scheduler(swapper)
  - 일단 모든 프로세스 READY
  - 메모리에 프로세스가 너무 많이 올라오면 여유 공간 확보를 위해 프로세스 통째로 메모리에서 디스크로 쫓아낸다.
  - 프로세스에게서 메모리를 뺏는 문제를 다룬다.
  - **degree of Multiprogramming**을 제어한다.

- Medium-term scheduler로 인해 Suspended 상태가 생긴다.
  - 외부적인 이유로 프로세스의 수행이 정지된 상태이다.(사람이 하는 것도 포함)  
  - 프로세스가 통째로 디스크로 쫓겨난다(swap out).
  - 예) 사용자가 프로그램을 일시 정지 시킨 경우, 메모리에 프로세스가 너무 많아 중단 시킨 경우
  - 외부에서 다시 재개 시켜 주어야 Active할 수 있다.
  - Blocked는 프로세스 본인은 열심히 작업 중, 자신이 요청한 event가 만족되면 다시 Ready
  
 # Process 2 & 3

### 동기식 입출력(Synchronous)

- 사용자 프로세스가 운영체제에게 입출력 요청을 하고 기다리는 입출력 방법이다.
- 입출력이 끝나는 것을 기다린다.
- 구현 방법 1 : cpu 제어권을 가진 상태에서 입출력을 기다리는 방식으로 cpu가 낭비된다.
- 구현 방법 2 : cpu 제어권을 다른 프로세스에게 넘기고 기다리는 방식이다.

### 비동기식 입출력(Asynchronous)

- 입출력이 진행되는 동안 그 프로세스가 cpu 제어권을 잡아서 cpu가 인스트럭션을 수행시키는 입출력 방법이다.

## 스레드(Thread)

![스레드](https://user-images.githubusercontent.com/62707891/178996061-e0ad0536-1081-4bc6-8350-654eee1ffa63.jpg)

- 프로세스 내부의 cpu 수행 단위.
- 주소 공간에 프로세스를 하나만 띄워 놓은 후 스레드마다 다른 부분을 실행할 수 있게 한다.
- 메모리, 자원 등을 공유하지만 별도로 cpu 수행과 관련된 정보를 가지고 있으며, 프로세스 실행 부분을 가리키는 프로그램 카운터, 레지스터,  함수 호출과 관련된 스택을 별도로 가지고 있다.
- 동일한 작업을 수행하는 프로세스를 여러 개 두면 메모리가 낭비된다.
- 동일 작업을 하면 주소 공간을 하나만 두고, 커널 공간의 pcb에 program counter, register 여러 개 둔다. 
- 스레드가 코드를 실행하다가 함수를 호출하면 stack에 쌓아야 하는데, 이 때 스택도 스레드 당 별도로 나누어야 한다. 

#### Thread는 가벼운 프로세스(lightweight process)

### Thread의 구성

- program counter
- register set
- stack space

### Thread가 동료 Thread와 공유하는 부분(=task)

- code section
- data section
- OS resources

### 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task이다.

## Thread의 장점

- **응답성(Responsiveness)**
  - 스레드를 사용하면 사용자 입장에서 빠르다.
  - 하나의 서버 스레드가 blocked 상태여도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리 가능.
  - 보통 웹 브라우저를 키면 웹 서버에서 html문서를 읽어온 후 이미지가 있으면 다시 웹 서버에게 이미지를 요청해서 창에 띄우게 된다.
  - 보통 이 과정이 오래 걸리기 때문에 프로세스 block 시키는데 여러 개의 스레드를 사용하면 스레드가 block 돼도 다른 스레드가 html문서를 읽어 텍스트라도 띄워 놓는 작업을 수행하기 때문에 빠르다
  - 일종의 비동기식 입출력 io 던져 놓고 다른일 하는 방식 
- **자원 공유(Resource Sharing)**
  - 같은 일을 하는 프로그램을 별도의 프로세스로 만드는 것 보다는 하나의 프로세스를 두고 여러 개의 스레드를 사용하면 코드, 데이터, 각종 자원을 공유하여 자원을 더 효율적으로 사용할 수 있다.
  - 같은 문서 편집기(word, 한글) 여러 개 띄워둘 때 각각 프로세스로 만들면 낭비 

- **경제성(Economy)**
  - 프로세스를 만드는 것은 부담이 크지만 스레드 하나 만드는 것은 그렇게 부담이 크지는 않다.
  - 문맥 교환 또한 부담이 꽤 크지만 스레드간 cpu 교환은 동일한 주소 공간을 사용하고 있기 때문에 대부분의 문맥을 그대로 사용할 수 있기 때문에 부담이 적다.
  - 유닉스의 일종인 솔라리스에서 생성과 cpu switching의 경우 프로세스가 각각 30배, 5배의 오버헤드가 크다.
- **병렬성(Utilization of MP Architectures)**
  - 행렬간 곱셈 시 병렬 적으로 처리하면 일 처리가 빨라진다. 
  - 동일한 일을 수행하는 다중 스레드가 협력하면 처리율이 높다.
  - 스레드가 여러 개 있으면 cpu가 여러 개 있는 상황에서 매우 효율적이다.
  - 스레드가 서로 다른 cpu에서 병렬적으로 일을 하면 굉장히 빠르기 때문이다.
  - 위의 다른 장점과 달리 멀티 프로세서 환경에서의 장점이다.

### Kernel Threads

- 커널 스레드는 스레드가 여러개 있다는 것을 운영체제가 알고 있다.
- 하나의 스레드에서 다른 스레드로 cpu 제어권이 넘어갈 때도 커널이 cpu 스케줄링하듯이 넘겨주게 된다.

### User Threads

- 유저 스레드는 라이브러리를 통해 지원 된다.
- 운영체제가 모르며, 유저 프로세스가 스스로 여러 스레드를 관리한다.
- 그렇기 때문에 구현 상의 제약 점이 있다.
- 커널의 지원을 받지 않기 때문에 
 

# 🌐 CPU Scheduling 1

- 모든 프로그램은 CPU burst와 I/O burst를 번갈아 수행하는 방식으로 진행된다.
- CPU burst가 길기도 하고 짧기(I/O가 자주 끼어들어서)도 한 경우가 있기 때문에 어떤 프로세스에게 CPU를 줄지 결정하는 CPU 스케줄링이 필요하다.
- interactive한 프로그램(I/O bound job)에게 cpu 할당을 늦게 해주면 사람이 너무 많이 기다려야 한다. 

## CPU Scheduling의 주요 이슈

- **CPU burst 상태의 여러 프로세스 중 어떤 프로세스에게 CPU를 주어야 하는지?**
- **CPU burst 동안 일단 CPU를 주면 계속 주어야 하는지 혹은 중간에 뺏어야 하는지?**
    - nonpreemptive는 CPU를 강제로 뺏기지 않고 자진 반납하는 방법 
    - preemptive는 강제로 뺏기는 방법으로 현대적인 방법이다.

## Scheduling 성능 척도(Scheduling Criteria)

- CPU Utilization(CPU 이용률, 시스템 입장)
    - 전체 시간 중에서 CPU가 놀지 않고 일 한 시간의 비율이다.(가능한 바쁘게 일을 시켜라)
- Throughput(처리량,시스템 입장)
    - 주어진 시간 동안 몇 개의 작업을 수행한 일의 양으로 주어진 시간 동안 많은 일을 하는 것이 좋다.
-  Turnaround time(소요시간, 반환시간, 프로그램 입장)
    - CPU를 사용하기 위해 들어와서 다 쓰고 나가는 때 까지 걸린 시간.(CPU burst에서 다 쓰고 나갈 때 까지, 가능한 빨리 쓰고 나가고 싶다)
-  Waiting time(대기 시간, 프로그램 입장)
    - CPU를 쓰기 위해 기다린 시간이다.
    - 비자발적으로 뺏기는 프로그램의 경우 한 번의 프로그램 동안 CPU를 얻었다 뺐겼다를 반복하는데 총 기다린 시간이 대기 시간이다.
-  Response time(응답 시간, 프로그램 입장) **다시 공부**
    - 처음으로 CPU를 쓰겠다고 들어와서 **처음으로** CPU를 얻는데 걸린 시간이다. 대기 시간과는 다른 의미이다.
    - 처음으로 CPU를 얻는 시간이 사용자 응답 측면에서 중요.

## CPU Scheduling 알고리즘

### FCFS(First-Come First-Service)

- 먼저 온 프로세스에게 먼저 CPU를 주는 알고리즘
- CPU를 오래 사용하는 프로세스가 먼저 오면 짧게 쓰는 프로세스가 오래 기다려서 대기 시간이 매우 길어지기 때문에 **비효율적**이다.
- nonpreemptive
- 앞의 CPU 사용이 긴 프로세스 때문에 자신의 사용이 늦어지는 것을 콘보이 효과(Convoy effect)라고 한다.

### SJF(Shortest-Job-First)

- CPU 사용 시간이 짧은 프로세스에게 먼저 CPU를 주는 알고리즘이다.
- Nonpreemptive
    - 더 짦은 프로세스가 나중에 도착하더라도 지금 사용 중인 프로세스가 모두 마칠 때 까지 기다려야 하는 방법이다.
    - 프로세스가 CPU를 다 쓰고 나간 시점에 스케줄링이 이루어진다.
- Preemptive
    - CPU사용 시간이 작은 새 프로세스가 들어오면 CPU를 뺏어서 넘겨준다.
    - 남은 시간이 더 짧은 프로세스에게 CPU를 주기 때문에 Shortest-Remaining-Time-First 라고도 부른다.
    - 새로운 프로세스가 도착하면 스케줄링이 이루어진다.
    - minimum average waiting time을 보장
- 문제점
    - **Starvation**(기아 현상) : 극단적으로 cpu 사용이 짧은 것을 선호하기 때문에 cpu사용이 길면 계속 짧은 시간 사용하는 프로세스가 계속 들어와서 영원히 서비스 못 받을 수도 있다.
    - cpu사용 시간을 미리 알 수가 없다. : cpu를 할당 받아서 얼마나 쓰고 나갈지 알 수가 없다.
        - 수식을 통해 CPU사용 시간을 예측(추정)하여 해결할 수 있다.(과거 패턴을 통해서, 과거로 갈 수록 적게 반영해서)
    
    

### Priority Scheduling

- 우선순위가 높은 프로세스에게 CPU를 먼저 준다.
- 우선순위가 높은 프로세스가 도착했을 때 CPU를 뺏을 수 있느냐에 따라 **Preemptive**과 **Nonpreemptive**으로  나눌 수 있다.
- 일반적으로 리눅스 같은 운영체제 에서는 숫자(보통 정수)가 낮을수록 우선순위가 높다.
- CPU 사용 시간이 적은 프로세스가 우선순위가 높다면 SJF이다.
- 문제점
    - **Starvation**(기아 현상) 
- 해결
    - Aging : 우선순위가 아무리 낮아도 기다린 시간이 지날 수록 우선순위가 높아지도록 하는 방법.

### Round Robin(RR)
- Preemptive
- 현대적인 시스템의 스케줄링은 라운드 로빈에 기반을 두고 있다.
- 각 프로세스는 동일한 크기의 할당 시간을 가진다.
- 할당 시간이 지나면 CPU 제어권을 잃고 Ready queue로 간다.
- 누가 짧게 쓰고 누가 길게 쓸 지 모르는 상황에서 모든 프로세스가 짧게 쓰고 나간다는 장점이 있다.
- 할당 시간이 매우 길면 FCFS와 유사하다.
- n개의 프로세스가 ready queue에 있고 할당 시간이 q time unit(10~100 ms)이라면 프로세스는 최대 q time unit 단위로 cpu시간의 1/n을 얻는다.
    - **어떤 프로세스도 (n-1)/q time unit 이상 기다리지 않는다.**
    - cpu 사용 시간이 짧으면 전체적인 waiting 시간은 짧다.
- 너무 짧으면 문맥 교환이 자주 일어나 오버헤드가 커진다.
- 타이머를 사용하기 때문에 **응답 시간이 빠르다**.
- 다만 **대기 시간, Turnaround time은 앞선 알고리즘보다 길 수 있다**.
- 응답 시간이 짧기 때문에, CPU 사용 시간을 알 수 없을 때 사용하면 효율적이다.

# 🌐 CPU Scheduling 2 / Process Synchronization 1

기존의 한 줄로 기다리는 CPU Scheduling 만으로는 부족한 점을 보완하기 위해서 여러 줄에서 CPU 사용을 기다리는 방법이 고안되었다. 

## CPU Scheduling 알고리즘

### Multilevel Queue

- Ready queue를 여러 개로 분할하는 방법이다.
    - interactive한 프로세스가 줄을 서는 queue가 모인 **foreground** 부분이 있고,
    - interactive하지 않거나 CPU만 오래 사용하는 배치한 queue가 모인 **background** 부분으로 나뉜다.
    
- 각 큐는 독립적인 스케줄링 알고리즘을 가진다.
    - background 작업은 주로 CPU만 오래 사용하는 프로세스여서 응답 시간이 빨라도 좋을 것이 없기 때문에 자주 CPU를 줬다 뺏었다 하는 것보다 FCFS 방식을 사용하여 문맥 교환 오버 헤드를 줄인다.
    - background는 FCFS
    - foreground는 Robin Round
- 큐에 대한 스케줄링이 필요하다.(어떤 큐에게 CPU를 줄지 결정하고, 그 다음 어떤 프로세스에게 CPU를 줄지 결정한다.)
    - 우선순위가 고정된 스케줄링
        - foreground의 프로세스를 가장 우선해서 처리한다.
        - 때문에 background 프로세스의 스타베이션 문제를 유발할 수 있다.
    - Time Slice
        - 각 큐에 CPU 시간을 적절한 비율로 할당한다.
        - 예) 우선순위가 높은 것(RR)을 80% 낮은 것(FCFS)을 20%
![multilevel-queue-scheduling](https://user-images.githubusercontent.com/62707891/181872701-ead59a88-44e4-4645-9379-505aa7cb34ef.jpg)

### Multilevel Feedback Queue

- Multilevel Queue에서 우선순위를 영원히 극복하지 못하는 문제점 때문에 생긴 방식이다.
- 프로세스가 다른 큐로 이동이 가능하다.
- 에이징을 이와 같은 방식으로 구현할 수 있다.
- Multilevel Feedback Queue scheduler를 정의하는 파라미터들
    - Queue의 수
    - 각 큐의 scheduling 알고리즘
    - process를 상위 큐로 보내는 기준
    - process를 하위 큐로 보내는 기준
    - 프로세스가 CPU를 할당 받을 때 들어갈 큐를 결정하는 기준
        - 보통 처음 들어오는 프로세스는 우선순위가 가장 높은 큐에 넣는다.
        - 우선순위가 높은 큐는 RR 사용하고 할당 시간을 매우 짧게 주고 밑으로 갈 수록 할당 시간을 점점 길게 주고 제일 아래 큐는 FCFS로 한다.
        - 우선순위가 높은 큐에서 해결이 안된 프로세스는 계속 우선순위가 낮은 큐로 내려간다.
 - 세개의 큐
    - Q0 = time quantum 8 milliseconds
    - Q1 = time quantum 16 milliseconds
    - Q2 = FCFS
 - 스케쥴링
    - new job이 Q0로 들어감
    - CPU를 잡아 할당받은 8ms 동안 작업 수행
    - 8ms동안 작업 다 수행 못했다면 Q1으로 내려감
    - 기다리다가 할당받은 16ms동안 작업 수행
    - 16ms동안 못하면 Q2로 내려가서 FCFS로 작업 수행
    
 ![feedbackqueue](https://user-images.githubusercontent.com/62707891/181872959-15549161-aeda-4fc9-8236-71d15127cc6f.png)


**스케줄링이 복잡해지는 상황들**

### Multiple-Processor Scheduling

- CPU가 여러 개 있을 경우 스케줄링이 복잡해진다.
- Homogeneous processor(코어가 두 개)인 경우
    - Queue에 한 줄로 세워서 각 프로세스가 알아서 꺼내가게 할 수 있다.
    - 반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우 문제가 복잡해진다.
- Load sharing
    - 일부 프로세서에 작업이 몰리지 않도록 부하를 적절히 공유하는 방법이 필요하다.
    - 별개의 큐를 두는 방법과 공동 큐를 사용하는 방법이 있다.
- Symmetric Multiprocessing(SMP)
    - 각 프로세서가 알아서 스케줄링을 결정한다.
- Asymmetric mutiprocessing
    - 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따르는 방식이다.
    

### Real-Time Scheduling

- **Hard real-time systems**
    - Hard real time task는 정해진 시간 안에 반드시 끝내도록 스케줄링이 필요하다.

- **Soft real-time computing**
    - soft real time task는 일반 프로세스에 비해 높은 우선순위를 갖게 한다.
    - 영화 플레이와 같이 우선순위를 높게 두지만 조금 어길 수도 있는 작업을 위한 스케줄링 방법이다.
    

### Thread Scheduling

- Local Scheduling
    - User level thread의 경우 운영체제가 스레드의 존재를 모르기 때문에 사용자 수준의 thread library에 의해 어떤 thread를 스케줄할지 결정한다.
    - 운영체제는 스레드를 모르기 때문에 프로세스에게 cpu를 줄지를 결정하고, 프로세스에게 CPU가 갔을 때 어떤 스레드에게 CPU를 줄지를 프로세스 내부에서 결정한다.

- Global Scheduling
    - Kernel level thread의 경우 일반 프로세스와 마찬 가지로 커널(운영체제)의 단기 스케줄러가 어떤 thread를 스케줄할지 결정한다.

### Algorithm 평가 방법

- Queueing models
    - 확률 분포로 도착률과 프로세스가 처리되는 처리율이 주어질 때 수식 계산을 통해서 성능을 계산한다.
    - 예전에 자주 사용하던 이론적인 방법이다.
- Implementation(구현) & Measurement(성능 측정)
    - 큐잉 모델과 상반되는 방법이다.
    - 구현해서 성능을 측정하는 방법이다.
- Simulation
    - 알고리즘을 모의 프로그램으로 작성 후 trace를 입력으로 하여 결과를 비교하는 방법
    - 실제 프로그램의 CPU burst 패턴을 확보하여 시뮬레이션 하는 방법이다.
    - 실제 프로그램으로부터 추출한 입력 데이터를 trace라고 한다.

## Process Synchronization 문제

- 공유 데이터의 동시 접근은 데이터의 일관성을 해치는 문제를 발생 시킬 수 있다.
- 일관성을 유지하기 위해서는 협력 프로세스 간의 실행 순서를 정해주는 매커니즘이 필요하다.

### Race Condition
- 데이터가 저장되는 storage box를 여러 e box(cpu process)가 사용하는 경우 Race Condition이 발생할 경우가 많다.
- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황이다.
- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라지게 된다.

### Race Condition이 발생하는 경우

1. 커널 모드에서 수행 중 인터럽트가 발생하여 인터럽트 처리 루틴이 수행되는 경우
    - 양쪽 다 커널 코드 이므로 커널 주소 공간을 공유하기 때문에 발생한다.
        - 예를 들어 커널이 어떤 변수를 1 증가 시키는 경우 메모리의 변수를 CPU 안에 레지스터에 읽어 들이고, 연산하고, 다시 메모리에 넣는데
        - 하지만 읽어 들인 상태에서 인터럽트가 들어와 인터럽트 루틴을 처리하는데 그 루틴이 아까의 변수를 1 감소 시키는 작업이라면?
        - 원래 결과는 +1 -1 해서 원래의 값이여야 하지만, 미리 레지스터에 읽어 들인 상태여서 결과는 처음 변수+1이 되게 된다.
    - 인터럽트가 들어와도 인터럽트 멈췄다가 작업을 마친 후에 인터럽트 루틴을 수행하여서 문제를 해결할 수 있다.
        - 비효율적일 수 있다. 
      
2. 프로세스들이 본인이 직접 실행할 수 없는 코드에 대해서는 시스템 콜로 운영체제에게 요청하는데 되어 커널의 코드가 프로세스를 대신해서 실행이 되고, 커널의 데이터에 접근하게 되는 중 CPU를 뺏겨서 다른 프로세스에게 넘어가는데 이 때 CPU를 넘겨 받은 프로세스가 또  다시 시스템 콜을 하여 커널의 데이터에 접근하면서  문제가 발생한다. 
    - 프로세스가 커널 모드에 있을 때는 할당 시간이 끝나도 CPU를 뺏기지 않게 하여 문제를 해결한다.
    - 할당을 초과할 수도 있지만 실시간 시스템이 아니기 때문에 약간의 오차가 있어도 무방
3. 멀티 프로세서를 사용하면서 발생하는 문제
    - 이전의 해결 방법으로는 문제를 해결할 수 없다.
    - cpu가 데이터 접근해서 수정할 때 **락(lock)**을 걸어서 누구도 접근하지 못하게 하여 해결하는 방법이 있다.
    - 한번에 하나의 cpu만 커널에 들어갈 수 있게 하는 해결 방법이 있다. 커널에 락을 거는 방법 위의 방법이 더 효율적이다.
- 프로세스의 경우 도중에 CPU를 빼앗겨도 공유 메모리를 사용하지 않는한 사용자 모드에서는 별 문제 없다.
- 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다.
- 일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정해주는 메커니즘이 필요하다.

## Critical Section

- 여러 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
- 각 프로세스의 code segment에는 **공유 데이터를 접근하는 코드인 Critical Section**이 존재한다.
- 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

## 객체 지향 프로그래밍I

### 객체 지향
- '실제 세계는 사물로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용'이 객체지향의 기본 개념이다.
- 실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 메서드로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현하고자 한 것.
- 객체 지향이란 프로그램을 객체들로 나누고 객체들의 상호작용으로 서술하는 방식의 개발 방법이다.
- 소프트웨어 개발 시 시스템에 대한 요구사항이 추가되거나 변하는데, 객체 마다 유연하게 프로그래밍하여 시스템의 확장이나 변경이 쉽게 대응할 수 있어 안정적인 유지 보수가 가능한 개발 방법.

### 객체 지향의 특징
- 코드의 재사용성이 높다.
  - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성 가능
- 코드의 관리가 용이하다.
  - 코드간의 관계를 이용해서 적은 로겨으로 쉽게 코드를 변경할 수 있다.
- 신뢰성이 높은 프로그래밍이 가능하게 한다.
  - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
- 직관적인 분석이 가능하고 코드의 재사용이 쉬운 장점을 가진다.
- 처리 속도가 상대적으로 느리고, 설계에 많은 시간을 소비해야하는 단점을 가진다.

### 클래스와 객체
- **클래스**는 객체를 정의해 놓은 것으로 객체를 생성하는데 사용된다.
- **객체**는 속성(멤버 변수)과 기능(메서드)의 집합이다.

### JVM의 메모리 구조
<img width="400" src="https://github.com/wonjaechoi97/Interview_Study/blob/main/Java/img/%EC%BD%9C%EC%8A%A4%ED%83%9D.png">

- 메서드 영역
  - 프로그램 실행 중 특정 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일을 읽어서 분석 후 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 클래스 변수도 같이 생성 된다.
- 힙(heap)
  - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성, 인스턴스 변수들이 생성되는 공간.
- 호출 스택(call stack or execution stack)
  - 메서드 작업에 필요한 메모리 공간 제공. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용, 메서드가 작업을 마치면 할당되었던 메모리 반환되면서 비워진다. 

### 클래스 메서드와 인스턴스 메서드
- 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static(클래스 변수로)을 붙인다.
- 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
  - 클래스 변수는 클래스가 메모리에 올라갈 때 이미 생성되었기 때문
- 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
  - 인스턴스 변수는 인스턴스가 생성되어야 Heap 영역에 생성되는데, 아직 생성되지 않았을 경우도 있기 때문에 사용 불가.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려 
  - static 메서드는 실행 시 호출되어야할 메서드 찾는 과정이 단축되기 때문에 성능이 향상된다.
  
### 오버로딩(overloading)
#### 오버로딩이란
 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라고 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의
#### 오버로딩의 조건
- 메서드 이름이 같아야 함
- 매개변수의 개수 또는 타입이 달라야 함.
- **반환타입은 달라도 아무 영향을 줄 수 없기** 때문에 반환 타입만 다를 경우 컴파일 시 에러 발생
- EX
  - void println ()
  - void println (boolean x)
  - void println (char x)
  - void println (char[] x)
  - ...
- 만약 예시와 같은 경우에 모든 메서드의 이름이 다르다면 들어오는 매개변수의 종류에 따라 메서드의 이름을 만들어 줘야하기 때문에 메서드 명을 만드는 것과 이름을 외워서 사용하는 것 모두 어렵기 때문에 번거롭다. 매개변수로 어떤 타입을 넣어주던지 println만 기억하면 되기 때문에 편리하다.
- 메서드의 이름이 같으니 아 비슷한 기능을 하겠구나 유추할 수 있다.

# 채워넣기

## 객체 지향 프로그래밍II

### 상속
#### 상속이란
- 기존의 클래스를 재사용하여 클래스를 작성하는 것
- 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
#### 상속의 장점
- 코드의 재사용성이 높고, 코드의 중복을 제거하여, 프로그램의 생산성과 유지보수에 크게 기여한다.
- 자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.(역방향은 성립 x)
  - 조상 클래스에 멤버 하나를 추가하면, **자손 모두가 멤버하나를 추가**하게 된다.
#### 상속의 특징
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- `child1`, `child2`가 `parent`를 상속 받고 있고, `child1`, `child2` 모두 추가할 멤버가 있다면 `parent`에 하는 것이 효율적이다. &rarr; `중복 제거`

#### 클래스간의 관계 - 포함 관계(has a)
- **한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것**
``` java
class Point {
  int x;
  int y;
}

class Circle {
  Point c = new Point(); // int x, int y 중복 선언 보다는 Point 타입 변수를 선언하는 것이 편리하다.
  int r;
}
```
- 하나의 거대한 클래스를 작성하기 보단 여러 개의 단위 클래스를 작성하고 포함관계를 활용해 재사용하면 간결하고 손쉽게 클래스 작성 가능.
- 작성된 단위 클래스들을 다른 클래스들 작성하는데 *재사용*할 수 있다.
#### 다중 상속
- 다중 상속은 불가능하므로 다른 클래스 타입의 참조변수 선언해서 사용 
- 다음과 같이 VCR 클래스와 일치하는 선언부를 가진 메서드를 선언해서 사용한다.
  - TVCR인스턴스를 사용하는 듯 보이지만 내부적으로는 VCR 인스턴스를 사용한다. 
``` java
class TVCR extends Tv{
  VCR vcr = new VCR();
  
  void play() {
    vcr.play();
  }
}
```
### 오버라이딩

#### 오버라이딩이란?
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 오버라이딩 메서드의 내용만 변경, 메서드의 선언부는 조상 것과 완전히 같아야 한다.
#### 오버로딩 VS 오버라이딩
- 오버로딩 : 기존의 없는 새로운 메서드를 정의하는 것
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는

#### 오버라이딩 조건 
- 자손 클래스와 오버라이딩하는 메서드는 조상 클래스 메서드와
  - 이름 같아야 한다.
  - 매개변수가 같아야 한다.
  - 반환타입이 같아야 한다.
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
  - 조상 클래스가 `protected`이면 적어도 `protected`, `public`.
  - private<(default)<protected<public 
- 조상 클래스의 메서드보다 많은 수의 예외 던지기 불가.
  - 아래의 두 번째 경우에는 모든 예외의 최고 조상인 Exception을 던졌기 때문에 더 많은 예외를 던져서 오류가 있다.
                                       
``` java
//잘된 경우
class Parent {                                    
  void parentMethod() throws IOException, SQLException {
  ...                            
  }
}
                                       
class Child extends Parent {                                    
  void parentMethod() throws IOException {
  ...                            
  }
}
                                       
// 잘못된 경우                                       
class Child extends Parent {                                    
  void parentMethod() throws Exception {
  ...                            
  }
}
```
#### super
- 조상 클래스의 멤버와 자손 클래스의 멤버를 구분하기 위해 사용하는 것.
- 모든 인스턴스 메서드가 가지고 있는 자신이 속한 `인스턴스의 주소`를 가진 지역변수가 `this`, `super`의 값이 된다.
- 다음의 경우 `this.x = 20 super.x = 10`가 정답
- 이처럼 조상 클래스에 선언된 멤버 변수와 같은 이름의 멤버 변수를 자손 클래스에서 중복 정의하는 것도 가능하다.
``` java
class Parent{
  int x = 10;
}

class Child extends Parent{
  int x = 20;
  void method(){
    sout("this.x = " + this.x);
    sout("super.x = "+ super.x);
  }
}
```
- 메서드 역시 super를 통해 조상 메서드를 호출 가능
  - 조상 클래스의 메서드의 내용에 *추가적으로* 작업을 덧붙이는 경우
  - 이후 조상 클래스의 메서드가 변경되면 변경된 내용이 반영된다.

``` jav
class Point{
    int x;
    int y;

    String getLocation() {
        return "x : " + x + ", y :" + y;
    }
}

class Point3D extends Point{
    int z;
  
    String getLocation(){
        // return "x :" + x + ", y :" + y + , z :" + z;
        return super.getLocation() + ", z :" + z;
    }

}
```

#### super() - 조상 클래스의 생성자
- 자손 클래스가 인스턴스하면 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.
- 그렇기 때문에 조상의 멤버에 대한 초기화가 필요하기 때문에 조상 클래스의 생성자가 호출 되어야 한다.
  - Object까지 계속된다.
- Object 제외한 모든 클래스의 생성자는 **첫 줄에 반드시 자신의 다른 생성자나 조상의 생성자 호출해야한다.**
  - 없다면 컴파일러가 자동으로 `super();`를 추가한다.
    - 하지만 `super();` 시행 시 조상 클래스에 파라미터 없는 생성자가 없다면 오류가 발생한다. 
``` java
class Point{
    int x,y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }

    String getLocation() {
        return "x : " + x + ", y :" + y;
    }
}

class Point3D extends Point{
    int z;
    public Point3D2(int x, int y, int z){
        super(); // <--- 여기서 컴파일 에러 1. Point()를 추가, 2. super(x,y);를 추가하는 방식으로 해결한다. 
        this.x = x;
        this.y = y;
        this.z = z;
    }
   
    String getLocation(){
        return "x :" + x + ", y :" + y + , z :" + z;
    }
}
```
- 어떤 클래스의 인스턴스를 생성하면 클래스 상속관계의 최고조상인 Object클래스까지 거슬러 올라가면서 모든 조상 클래스의 생성자가 순서대로 호출된다.

### Package와 import 
#### package
- `패키지`란 클래스의 묶음
- 서로 관련된 클래스끼리 그룹 단위로 묶어서 크래스를 효율적으로 관리할 수 있다.
- 서로 다른 패키지에는 같은 이름의 클래스가 존재할 수 있어서 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름 충돌 방지가 가능하다.
- 클래스의 풀 네임은 패키지명을 포함한 것
  - `ex)` java.lang.String
- 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조를 구성할 수 있다.
- 패키는 물리적으로 클래스 파일(.class)를 포함하는 **하나의 디렉토리**

#### 패키지의 선언
- 주로 소문자 사용(클래스와 구분 위해)
``` java
//주석과 공백을 제외한 가장 첫번째 문장이 패키지 선언
package 패키지명;
```

``` java
package com.codechobo.book;

class PackageTest {
  public static void main(String[] args){
    System.out.println("Hello World!");
  }
  
}
```
- 위의 `.java`파일 생성 후 `-d`옵션을 추가하여 컴파일 한다.
``` 
C : \jdk1.8\work>javac -d . PackageTest.java
```
- `-d` 이후 지정된 경로를 통해 패키지 위치를 찾아 클래스 파일 생성
  - 지정된 패키지와 일치하는 디렉토리 존재하지 않는다면 **자동으로 생성**
- `-d .` : 루트 디렉토리를 경로로 설정 
  - `C : \jdk1.8\work\com\codechobo\book` 위치에 PackageTest.class 파일 생성된다.
- 이후 이 클래스를 사용하기 위해서는 이 클래스의 루트 디렉토리인 `C : \jdk1.8\work`를 클래스패스에 추가해야 한다. 
  - 이렇게 해야 이후 JVM이 PackageTest 클래스를 찾을 수 있다.
- 추가하는 방법은 윈도우의 경우 `환경 변수 - 새로 만들기`에서 변수 이름을 `CLASSPATH`를 입력하고 변수 값에는 `.;C : \jdk1.8\work"를 입력
  - `;`를 구분자로 여러 개의 경로를 클래스패스로 지정가능
  - 따로 `CLASSPATH` 생성하지 않으면 기본적으로 현재 디렉토리인 `.`가 클래스패스로 지정됨
  - `jar`파일 추가 위해서는 **경로와 파일명** 추가 필수
    - `ex)` `C : \jdk1.8\work\util.jar`
- JDK에 기본적으로 설정되어 있는 클래스패스를 이용하면 따로 설정 필요 없음
  - 추가하고자 하는 클래스를 `JDK설치디렉토리\jre\classes`디렉토리에 
  - `jar`파일인 경우 `JDK설치디렉토리\jre\lib\ext` 디렉토리에 
### 3.3 import문
- import 문을 사용해서 클래스의 패키지명을 명시해서 소스코드에 사용되는 클래스이름에서 패키지명 생략 가능하다.
  - 컴파일러에게 패키지에 대한 정보를 제공하는 것.
  - 컴파일러가 사용된 모든 클래스의 패키지를 알아낸 다음, 모든 클래스 이름 앞에 패키지명을 붙여준다.
  
### 3.4 import 문의 선언
- import문은 package 선언문 다음 클래스 선언문 이전에 위치해야 한다.
- 한 소스파일 안에서 여러 번 선언할 수 있다.
``` java
import 패키지명.클래스명;
//or
import 패키지명.*; //패키지 내에서 여러 클래스를 사용할 때
```


- 클래스 이름 대신 `*`을 사용하는 것이 하위 패키지의 클래스를 포함하는 것은 아니다.
``` java
import java.util.*;
import java.text.*;

//위 두개를 아래 하나로 대체할 수 없다!!
import java.*;

```
- 같은 패키지 안의 클래스는 패키지명 생략할 수 있다.

### 3.5 static import 문
- static import 문을 사용하면 static 멤버 호출 시 클래스 이름 생략 가능하다.
```java
import static java.lang.Integer.*; //--> Integer클래스의 모든 static 메서드
import static java.lang.Math.random; //Math.random()만. 괄호 안붙임.
import static java.lang.System.out; // System.out을 out만으로 참조가능
```

`System.out.println(Math.random());`->`out.println(random());`

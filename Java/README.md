# Java 공부 정리

## 객체 지향
- '실제 세계는 사물로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용'이 객체지향의 기본 개념이다.
- 실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 메서드로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현하고자 한 것.
- 객체 지향이란 프로그램을 객체들로 나누고 객체들의 상호작용으로 서술하는 방식의 개발 방법이다.
- 소프트웨어 개발 시 시스템에 대한 요구사항이 추가되거나 변하는데, 객체 마다 유연하게 프로그래밍하여 시스템의 확장이나 변경이 쉽게 대응할 수 있어 안정적인 유지 보수가 가능한 개발 방법.
### 객체 지향의 특징
- 코드의 재사용성이 높다.
  - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성 가능
- 코드의 관리가 용이하다.
  - 코드간의 관계를 이용해서 적은 로겨으로 쉽게 코드를 변경할 수 있다.
- 신뢰성이 높은 프로그래밍이 가능하게 한다.
  - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
- 직관적인 분석이 가능하고 코드의 재사용이 쉬운 장점을 가진다.
- 처리 속도가 상대적으로 느리고, 설계에 많은 시간을 소비해야하는 단점을 가진다.

### 클래스와 객체
- **클래스**는 객체를 정의해 놓은 것으로 객체를 생성하는데 사용된다.
- **객체**는 속성(멤버 변수)과 기능(메서드)의 집합이다.

### 객체지향의 구성요소
#### 캡슐화
- 변수와 메서드를 하나의 클래스의 정의해서 서로 관계가 깊은 변수와 함수를 함께 다룰 수 있도록 하고 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 한다.
- 예) 시간을 다루는 경우 
  - 객체지향적 코드 
  ```java
  class Time{
    int hour;
    int minute;
    float second;
  }
  
  Time t1 = new Time();
  Time t2 = new Time();
  Time t3 = new Time();
  
  //배열에 담는 경우
  Time[] t = new Time[3];
  t[0]=new Time();
  t[1]=new Time();
  t[2]=new Time();
  ```
  - 비객체지향적 코드: 시간, 분, 초를 따로 변수 선언하는 방법
  ```java
  int hour1, hour2, hour3;
  int minute1, minute2, minute3;
  int second1, second2, second3;
  
  //배열에 담는 경우
  int[] hour = new int[3];
  int[] minute = new int[3];
  int[] second = new int[3];
  ```
#### 정보 은닉
#### 상속
- 아래에 정리
#### 다형성
- 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어내는 성질을 의미한다. 

### JVM의 메모리 구조
<img width="400" src="https://github.com/wonjaechoi97/Interview_Study/blob/main/Java/img/%EC%BD%9C%EC%8A%A4%ED%83%9D.png">

- 메서드 영역
  - 프로그램 실행 중 특정 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일을 읽어서 분석 후 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 클래스 변수도 같이 생성 된다.
- 힙(heap)
  - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성, 인스턴스 변수들이 생성되는 공간.
- 호출 스택(call stack or execution stack)
  - 메서드 작업에 필요한 메모리 공간 제공. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간겨로가 등을 저장하는데 사용, 메서드가 작업을 마치면 할당되었던 메모리 반환되면서 비워진다. 

### 클래스 메서드와 인스턴스 메서드
- 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static(클래스 변수로)을 붙인다.
- 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
  - 클래스 변수는 클래스가 메모리에 올라갈 때 이미 생성되었기 때문
- 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
  - 인스턴스 변수는 인스턴스가 생성되어야 Heap 영역에 생성되는데, 아직 생성되지 않았을 경우도 있기 때문에 사용 불가.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려 
  - static 메서드는 실행 시 호출되어야할 메서드 찾는 과정이 단축되기 때문에 성능이 향상된다.
  
### 오버로딩(overloading)
#### 오버로딩의 조건
- 메서드 이름이 같아야 함
- 매개변수의 개수 또는 타입이 달라야 함.
- **반환타입은 달라도 아무 영향을 줄 수 없기** 때문에 반환 타입만 다를 경우 컴파일 시 에러 발생
- EX
  - void println ()
  - void println (boolean x)
  - void println (char x)
  - void println (char[] x)
  - ...
- 만약 예시와 같은 경우에 모든 메서드의 이름이 다르다면 들어오는 매개변수의 종류에 따라 메서드의 이름을 만들어 줘야하기 때문에 메서드 명을 만드는 것과 이름을 외워서 사용하는 것 모두 어렵기 때문에 번거롭다. 매개변수로 어떤 타입을 넣어주던지 println만 기억하면 되기 때문에 편리하다.
- 메서드의 이름이 같으니 아 비슷한 기능을 하겠구나 유추할 수 있다.


### 상속
#### 상속이란
- 기존의 클래스를 재사용하여 클래스를 작성하는 것
- 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
#### 상속의 장점
- 코드의 재사용성이 높다.
- 코드의 중복을 제거하여, 프로그램의 생산성과 유지보수에 크게 기여한다.
- 자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.(역방향은 성립 x)
  - 조상 클래스에 멤버 하나를 추가하면, **자손 모두가 멤버하나를 추가**하게 된다.


### 객체지향 설계 5 원칙 S.O.L.I.D
- S : Single Responsibility, 단일 책임 원칙
  - 클래스는 단 한개의 책임(기능)을 가져야 한다.
  - 하나의 책임이라는 것은 모호하다.
    - 클 수도 있고 작을 수도 있다.
    - 문맥과 상황에 따라 다르다   
  - **중요한 기준은 변경**, 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
  - 패키지로 계층을 잘 나눈 것은 이 원칙을 잘 지키기 위한 것 
  - 클래스를 변경하는 이유는 단 하나여아 한다.
  - 이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향을 미칠 수 있다.
    - 유지보수에 매우 비효율적  
- O : Open-Closed, 개방-폐쇄 원칙(**가장 중요한 원칙**)
  - 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.
  - 다형성을 활용하여, 역할과 구현의 분리를 통해 실현할 수 있다.
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다.
  ```java
  public class MemberService {
    
    private MemberRepository memberRepository = new MemoryMemberRepository();
    
  }
  
  
  public class MemberService {
    
  //  private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
    
  }
  
  
  ```
  - 구현 객체를 사용하기 위해서는 클라이언트 코드를 변경해야 한다.
  - 다형성을 잘 사용했지만 OCP 원칙을 지킬 수 없다.
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다 --> 스프링
- L : Liskov Substitution(LSP), 리스코프 치환 원칙
  -  프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  -  다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
  -  단순히 컴파일 성공하는 것을 넘어서는 이야기
  -  예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야한다.
- I : Interface Segregation(ISP), 인터페이스 분리 원칙
  - 특정 클라이언를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  - 사용자 클라이언트-> 운전자 클라이언트, 정비사 클라이언트로 분리
  - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
    - 인터페이스도 기능을 적당한 크기로 쪼개는 것이 좋다.  
- D : Dependency Inversion(DIP), 의존 역전 원칙(**중요**)
  - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
  - 쉽게 이야기 해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻.
  - **역할에 의존하게 해야 한다는 것과 같은 같다.** 
``` java
   public class MemberService {
    
  //  private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
    
  }
```
  - 이 경우 MemberService는 인터페이스 뿐만 아니라 MemoryMemberRepository라는 구현체에 대해서도 의존하고 있으므로, 다른 구현체로 변경할 때 코드의 변경이 발생한다.
  - DIP에 위반된다.
